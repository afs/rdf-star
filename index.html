<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>RDF*</title>
  <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
  <script class="remove">
   // All config options at https://respec.org/docs/
   var respecConfig = {
      specStatus: "CG-DRAFT",
      editors: [
        {
          "name": "Olaf Hartig",
          "url": "https://olafhartig.de/",
          "company": "Linköping University",
          "orcid": "0000-0002-1741-2090",
          "companyURL": "https://liu.se/",
        },{
          "name":       "Pierre-Antoine Champin",
          "url":        "http://champin.net/",
          "company":    "ERCIM",
          "companyURL": "https://www.ercim.eu/",
          "w3cid":      42931,
          "orcid": "0000-0001-7046-4474",
        },
      ],
      authors: [
        {
          "name": "Bryan Thompson",
          "company": "Amazon",
        },
      ],
      github: "w3c/rdf-star",
      shortName: "rdf-star",
      group: "rdf-dev",
      xref: ["RDF11-CONCEPTS", "SPARQL11-QUERY"],
    };
  </script>
  <style>
    /* copied from TR/turtle, and adapted for SPARQL rules */
    .grammar td { font-family: monospace; vertical-align: top; }
    .grammar-literal, .token { color: gray;}
    .grammar_comment { color: #A52A2A; font-style: italic; }
  </style>
  <script>
    /* copied from JSON-LD specs */
    function updateExample(doc, content) {
      // perform transformations to make it render and prettier
      return _esc(reindent(unComment(doc, content)));
    }

    function _esc(s) {
      return s.replace(/&/g,'&amp;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/</g,'&lt;');
    }

    function reindent(text) {
      // TODO: use trimEnd when Edge supports it
      const lines = text.trimRight().split("\n");
      while (lines.length && !lines[0].trim()) {
        lines.shift();
      }
      const indents = lines.filter(s => s.trim()).map(s => s.search(/[^\s]/));
      const leastIndent = Math.min(...indents);
      return lines.map(s => s.slice(leastIndent)).join("\n");
    }

    function unComment(doc, content) {
      // perform transformations to make it render and prettier
      return content
        .replace(/<!--/, '')
        .replace(/-->/, '')
        .replace(/< !\s*-\s*-/g, '<!--')
        .replace(/-\s*- >/g, '-->')
        .replace(/-\s*-\s*&gt;/g, '--&gt;');
    }
  </script>
</head>
<body>
  <section id="abstract">
    <p>TODO</p>
  </section>
  <section id="sotd">
  </section>

  <section id="introduction">
    <h1>Introduction</h1>

    <section class="informative">
      <h2>Background and Motivation</h2>

      <p>TODO, citing [[RDF-STAR-FOUNDATION]]</p>
    </section>

    <section class="informative">
      <h2>Overview</h2>

      <p>TODO</p>
      <p>The syntax of RDF is defined in two layers:</p>
      <ul>
        <li>the <dfn>abstract syntax</dfn>, which is the conceptual data model of RDF, and</li>
        <li>multiple <dfn data-cite="RDF11-CONCEPTS#dfn-concrete-rdf-syntax" data-lt="concrete syntax|concrete RDF syntax|concrete RDF syntaxes">concrete syntaxes</dfn> (such as RDF/XML [[RDF-SYNTAX-GRAMMAR]], Turtle [[TURTLE]] or JSON-LD [[JSON-LD11]]), which are data formats used to serialize the abstract syntax into files or over the wire.</li>
      </ul>
      <p>Similarly, this document defines the <a>abstract syntax</a> of RDF* in <a href="#concepts"></a>, and one <a>concrete syntax</a> based on Turtle [[TURTLE]] in <a href="#turtle-star"></a>.</p>
    </section>

    <section id="conformance">
      <p class=issue>TODO we may need to add more things here</p>
    </section>

  </section>

  <section id="concepts">
    <h2>Concepts and Abstract Syntax</h2>
    <p>An <dfn data-lt="graph">RDF* graph</dfn> is a set of <a>RDF* triples</a>.</p>

    <p>An <dfn data-lt="triple">RDF* triple</dfn> is a 3-tuple that consists of three components:</p>
    <ul>
      <li>the <dfn data-cite="RDF11-CONCEPTS#dfn-subject">subject</dfn>, which is an <a>IRI</a>, a <a>blank node</a> or an <a>RDF* triple</a>;
      <li>the <dfn data-cite="RDF11-CONCEPTS#dfn-predicate">predicate</dfn>, which is an <a>IRI</a>;
      <li>the <dfn data-cite="RDF11-CONCEPTS#dfn-object">object</dfn>, which is an <a>IRI</a>, a <a>literal</a>, a <a>blank node</a> or an <a>RDF* triple</a>;
    </ul>

    <p>The definition relies on the notions of <dfn data-cite="RDF11-CONCEPTS#dfn-iri">IRI</dfn>, <dfn data-cite="RDF11-CONCEPTS#dfn-literal">literal</dfn> and <dfn data-cite="RDF11-CONCEPTS#dfn-blank-node">blank node</dfn> introduced by [[[RDF11-CONCEPTS]]] [[RDF11-CONCEPTS]]. It extends the definition of <dfn data-cite="RDF11-CONCEPTS#dfn-rdf-triple">RDF triple</dfn> by allowing the <a>subject</a> and the <a>object</a> to be another <a>triple</a>.</p>

    <p>For every <a>RDF* triple</a> <var>t</var>, we define its <dfn>elements</dfn> as the set containing its <a>subject</a>, its <a>predicate</a>, its <a>object</a>, plus all the <a>elements</a> of its <a>subject</a> and/or its <a>object</a> if they are themselves <a>RDF* triples</a>. By extension, we define the <a>elements</a> of an <a>RDF* graph</a> to be the union set of the <a>elements</a> of all its triples.</p>

    <div class="example">
      Consider the following <a>RDF* triple</a> (represented in Turtle*):
      <pre class="nohighlight">
        &lt;&lt;_:a :name "Alice" >> :statedBy :bob.
      </pre>
      Its set of <a>elements</a> comprises the <a>IRIs</a> `:name`, `:statedBy`, `:bob`, the <a>blank node</a> `_:a`, the <a>literal</a> `"Alice"`, and the <a>triple</a> `&lt;&lt; _:a :name "Alice" >>`.
    </div>

    <p>An <a>RDF* triple</a> MUST NOT have itself as one of its <a>elements</a>.</p>

    <aside class="note">
      The restriction above means that <a>RDF* triples</a> can be recursively built by using “smaller” triples as their subject and/or object, but that a triple can not contain itself, neither directly (as its subject or object) nor indirectly (inside another triple used as subject or object). In other words, self-referential assertions (such as “this sentence has five words”) are out of scope of RDF*.
    </aside>

    <p>An <a>RDF* triple</a> used as the <a>subject</a> or <a>object</a> of another <a>RDF* triple</a> is called an <dfn data-lt="embedded">embedded triple</dfn>. An <a>RDF* triple</a> that is an element of an <a>RDF* graph</a> is called an <dfn data-lt="asserted">asserted triple</dfn>. Note that, in a given <a>RDF* graph</a>, the same <a>triple</a> MAY be both <a>embedded</a> and <a>asserted</a>.</p>

    <p><a>IRIs</a>, <a>literals</a>, <a>blank nodes</a> and <a>embedded triples</a> are collectively known as <dfn>RDF* terms</dfn>.</p>

    <p class="issue">The notion of <a>embedded triples</a> has a meaning only within the context of a given <a>RDF* graph</a>. In contrast, the notion of <a>RDF* terms</a> should be a general concept. Consequently, the notion of <a>RDF* terms</a> cannot be defined based on the notion of <a>embedded triples</a>. I propose to replace <a>embedded triples</a> in the definition by <a>RDF* triples</a>. -Olaf</p>

    <p>An <dfn data-lt="dataset">RDF* dataset</dfn> is a set {<var>G</var>, (<var>u<sub>1</sub></var>,<var>G<sub>1</sub></var>), ..., (<var>u<sub>n</sub></var>,<var>G<sub>n</sub></var>)} that consists of one <a>RDF* graph</a>&nbsp;<var>G</var>, called the <dfn data-lt="default-graph">default graph</dfn> of the dataset, and zero or more pairs (<var>u<sub>i</sub></var>,<var>G<sub>i</sub></var>) where each <var>u<sub>i</sub></var> is an <a>IRI</a> and each <var>G<sub>i</sub></var> is an <a>RDF* graph</a> such that all <var>u<sub>i</sub></var> are distinct within the dataset.</p>
  </section>

  <section id="turtle-star">
    <h2>Turtle*</h2>
    <p>In this section, we present Turtle*, an extension of the Turtle format [[TURTLE]] allowing to represent <a>RDF* graphs</a>. For the sake of conciseness, we only describe here the differences between Turtle* and Turtle.</p>

    <p class="issue">Is it enough to "patch" the Turtle Syntax and Parsing Section with RDF*-specific features, or should we </p>

    <section id="turtle-star-grammar">
      <h2>Grammar</h2>
      <p>Turtle* is defined to follow the <a data-cite="TURTLE#h3_sec-grammar-grammar">same grammar</a> as Turtle, <em>except</em> for the <a data-cite="XML#sec-notation"><abbr title="Extended Backus-Naur Form">EBNF</abbr> productions</a> specified below, which replace the productions with the same number (if any) in the original grammar.</p>

      <table class="grammar">
        <tr id="grammar-production-subject">
          <td>[10]</td>
          <td>`subject`</td>
          <td>::=</td>
          <td>
            <a data-cite="TURTLE#grammar-production-iri">iri</a> `|`
            <a data-cite="TURTLE#grammar-production-BlankNode">BlankNode</a> `|`
            <a data-cite="TURTLE#grammar-production-collection">collection</a> `|`
            <a href="#grammar-production-embTriple">embTriple</a>
          </td>
        </tr>
        <tr id="grammar-production-object">
          <td>[12]</td>
          <td>`object`</td>
          <td>::=</td>
          <td><a data-cite="TURTLE#grammar-production-iri">iri</a> `|`
            <a  data-cite="TURTLE#grammar-production-BlankNode">BlankNode</a> `|`
            <a  data-cite="TURTLE#grammar-production-collection">collection</a> `|`
            <a data-cite="TURTLE#grammar-production-blankNodePropertyList">blankNodePropertyList</a> `|`
            <a data-cite="TURTLE#grammar-production-literal">literal</a> `|`
            <a href="#grammar-production-embTriple">embTriple</a>
          </td>
        </tr>
        <tr id="grammar-production-embTriple">
          <td>[27]</td>
          <td>`embTriple`</td>
          <td>::=</td>
          <td>
            <code class="grammar-literal">'&lt;&lt;'</code>
            <a href="#grammar-production-embSubject">embSubject</a>
            <a data-cite="TURTLE#grammar-production-verb">verb</a>
            <a href="#grammar-production-embObject">embObject</a>
            <code class="grammar-literal">'&gt;&gt;'</code>
          </td>
        </tr>
        <tr id="grammar-production-embSubject">
          <td>[28]</td>
          <td>`embSubject`</td>
          <td>::=</td>
          <td><a data-cite="TURTLE#grammar-production-iri">iri</a> `|`
            <a  data-cite="TURTLE#grammar-production-BlankNode">BlankNode</a> `|`
            <a href="#grammar-production-embTriple">embTriple</a>
          </td>
        </tr>
        <tr id="grammar-production-embObject">
          <td>[29]</td>
          <td>`embObject`</td>
          <td>::=</td>
          <td><a data-cite="TURTLE#grammar-production-iri">iri</a> `|`
            <a  data-cite="TURTLE#grammar-production-BlankNode">BlankNode</a> `|`
            <a data-cite="TURTLE#grammar-production-literal">literal</a> `|`
            <a href="#grammar-production-embTriple">embTriple</a>
          </td>
        </tr>
      </table>

      <p class="note">The only changes are that <a href="#grammar-production-subject">`subject`</a> and <a href="#grammar-production-object">`object`</a> productions have been extended to accept <a>embedded triples</a>, which are described by the new productions <a href="#grammar-production-embTriple">27</a> to <a href="#grammar-production-embObject">29</a>. Note that <a>embedded triples</a> accept a more restricted range of <a>subject</a> and <a>object</a> expressions than <a>asserted triples</a>.</p>
    </section>

    <section>
      <h2>Parsing</h2>
      <p>A Turtle* parser is similar to a Turtle parser as defined in <a data-cite="TURTLE#h2_sec-parsing">Section 7 of the Turtle specification</a> [[TURTLE]], with an additional item in its state :</p>
      <ul>
        <li id="curObject"><a>RDF* Term</a> |curObject| — The |curObject| is bound to the <a href="#grammar-production-embObject">`embObject`</a> production.</li>
      </ul>
      <p>Additionally, the <a data-cite="TURTLE#curSubject">|curSubject|</a> can be bound to any <a>RDF* term</a> (including a <a>embedded triple</a>).</p>

      <p>A Turtle* document defines an <a>RDF* graph</a> composed of a set of <a>RDF* triples</a>. The <a href="#grammar-production-subject">`subject`</a> and <a href="#grammar-production-embSubject">`embSubject`</a> productions sets the |curSubject|. The <a data-cite="TURTLE#grammar-production-verb">`verb`</a> production sets the <a data-cite="TURTLE#curPredicate">|curPredicate|</a>. The <a href="#grammar-production-embObject">`embObject`</a> productions sets the |curObject|. For each <a href="#grammar-production-object">`object`</a> |N|, an <a>RDF* triple</a> |curSubject| |curPredicate| |N| is generated and added to the <a>RDF* graph</a>.</p>

      <p>Beginning the <a href="#grammar-production-embTriple">`embTriple`</a> production records the |curSubject| and |curPredicate|. Finishing the <a href="#grammar-production-embTriple">`embTriple`</a> production yields the <a>RDF* triple</a> |curSubject| |curPredicate| |curObject| and restores the recorded values of |curSubject| and |curPredicate|.</p>

      <p>All other productions MUST be handled as specified by <a data-cite="TURTLE#h2_sec-parsing">Section 7 of the Turtle specification</a> [[TURTLE]], while still applying the changes above recursively.</p>
    </section>

    <section class="informative">
      <h2>Other concrete syntaxes</h2>

      <p>While this document specifies only one <a>concrete syntax</a>, nothing prevents other <a>concrete syntaxes</a> of RDF* to be proposed. In particular, other existing <a>concrete syntaxes</a> for RDF, such as RDF/XML [[RDF-SYNTAX-GRAMMAR]], could be extended to support RDF*. In particular, the N-Triples syntax [[N-TRIPLES]] being a subset of Turtle, an appropriate subset of Turtle* could be defined to extend N-Triples accordingly.</p>
    </section>

  </section>

  <section>
    <h2>SPARQL*</h2>

    <p>This Section introduces SPARQL*, which is an RDF*-aware extension of the RDF query language SPARQL [[SPARQL11-QUERY]]; i.e., SPARQL* can be used to query RDF* graphs.</p>

    <section id="sparql-star-grammar">
      <h2>Grammar</h2>

      <p>SPARQL* is defined to follow the <a data-cite="SPARQL11-QUERY#sparqlGrammar">same grammar</a> as SPARQL, <em>except</em> for the <a data-cite="XML#sec-notation"><abbr title="Extended Backus-Naur Form">EBNF</abbr> productions</a> specified below, which replace the productions with the same number (if any) in the original grammar.</p>

      <table class="grammar">
        <tr id="rBind">
          <td>[60]</td>
          <td>`Bind`</td>
          <td>::=</td>
          <td>
            <code class="token">'BIND'</code>
            <code class="token">'('</code>
            (
              <a data-cite="SPARQL11-QUERY#rExpression">Expression</a> `|`
              <a href="#rEmbTP">EmbTP</a>
            )
            <code class="token">'AS'</code>
            <a data-cite="SPARQL11-QUERY#rVar">Var</a>
            <code class="token">')'</code>
          </td>
        </tr>
          <tr id="rTriplesSameSubject">
          <td>[75]</td>
          <td>`TriplesSameSubject`</td>
          <td>::=</td>
          <td>
            <a href="#rVarOrTermOrEmbTP">VarOrTermOrEmbTP</a>
            <a data-cite="SPARQL11-QUERY#rPropertyListNotEmpty">PropertyListNotEmpty</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rTriplesNode">TriplesNode</a>
            <a data-cite="SPARQL11-QUERY#rPropertyList">PropertyList</a>
        </td>
        <tr id="rObject">
          <td>[80]</td>
          <td>`Object`</td>
          <td>::=</td>
          <td>
            <a data-cite="SPARQL11-QUERY#rGraphNode">GraphNode</a> `|`
            <a href="#rEmbTP">EmbTP</a>
          </td>
        </tr>
        <tr id="rTriplesSameSubjectPath">
          <td>[81]</td>
          <td>`TriplesSameSubjectPath`</td>
          <td>::=</td>
          <td>
            <a href="#rVarOrTermOrEmbTP">VarOrTermOrEmbTP</a>
            <a data-cite="SPARQL11-QUERY#rPropertyListPathNotEmpty">PropertyListPathNotEmpty</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rTriplesNode">TriplesNode</a>
            <a data-cite="SPARQL11-QUERY#rPropertyListPath">PropertyListPath</a>
          </td>
        </tr>
        <tr id="rGraphNodePath">
          <td>[105]</td>
          <td>`GraphNodePath`</td>
          <td>::=</td>
          <td>
            <a href="#rVarOrTermOrEmbTP">VarOrTermOrEmbTP</a> `|`
            <a data-cite="SPARQL11-QUERY#rTriplesNodePath">TriplesNodePath</a> `|`
          </td>
        </tr>
        <tr id="rEmbTP">
          <td>[174]</td>
          <td>`EmbTP`</td>
          <td>::=</td>
          <td>
            <code class="token">'&lt;&lt'</code>
            <a href="#rEmbSubjectOrObject">EmbSubjectOrObject</a>
            <a data-cite="SPARQL11-QUERY#rVerb">Verb</a>
            <a href="#rEmbSubjectOrObject">EmbSubjectOrObject</a>
            <code class="token">'&gt;&gt'</code>
          </td>
        </tr>
        <tr id="rEmbSubjectOrObject">
          <td>[175]</td>
          <td>`EmbSubjectOrObject`</td>
          <td>::=</td>
          <td>
            <a data-cite="SPARQL11-QUERY#rVar">Var</a> `|`
            <a data-cite="SPARQL11-QUERY#rBlankNode">BlankNode</a> `|`
            <a data-cite="SPARQL11-QUERY#riri">iri</a> `|`
            <a data-cite="SPARQL11-QUERY#rRDFLiteral">RDFLiteral</a> `|`
            <a data-cite="SPARQL11-QUERY#rNumericLiteral">NumericLiteral</a> `|`
            <a data-cite="SPARQL11-QUERY#rBooleanLiteral">BooleanLiteral</a> `|`
            <a href="#rEmbTP">EmbTP</a>
          </td>
        </tr>
        <tr id="rVarOrTermOrEmbTP">
          <td>[176]</td>
          <td>`VarOrTermOrEmbTP`</td>
          <td>::=</td>
          <td>
            <a data-cite="SPARQL11-QUERY#rVar">Var</a> `|`
            <a data-cite="SPARQL11-QUERY#rGraphTerm">GraphTerm</a> `|`
            <a href="#rEmbTP">EmbTP</a>
          </td>
        </tr>
      </table>

      <p class="note">
        This introduces a notation for <a>embedded triples</a>
        (productions <a href="#rEmbTP">[174]</a> and following)
        similar to the one defined in <a href="#turtle-star"></a>,
        but accepting also <a>variables</a>.
        These <a>embedded triples</a> are allowed in subject
        (<a href="#rTriplesSameSubject">[75]</a>, <a href="#rTriplesSameSubjectPath">[81]</a>)
        and object
        (<a href="#rObject">[80]</a>, <a href="#rGraphNodePath">[105]</a>)
        position of <a>triple patterns</a>,
        as well as in BIND statements
        (<a href="#rBind">[80]</a>).
      </div>
    </section>

    <section>
      <h2>Algebra</h2>

      <p class="issue">In [[RDF-STAR-FOUNDATION]], the algebra is not based on [[SPARQL11-QUERY]], but on Pérez <i>et al.</i> 2009. To we want to keep this, or should we align more closely to the W3C spec?</p>

      <p>TODO here the definitions of
        <dfn>BGP*</dfn>,
        <dfn>embedded triple pattern</dfn>,
        <dfn>triple* pattern</dfn>,
        <dfn>SPARQL* expression</dfn>,
        <dfn>solution* mapping</dfn>,
        <dfn>evaluation</dfn>,
        ...
        We reuse from [[SPARQL11-QUERY]] the following terms:
        <dfn data-cite="SPARQL11-QUERY#defn_RDFTerm">RDF Term</dfn>,
        <dfn data-cite="SPARQL11-QUERY#defn_TriplePattern">triple patterns</dfn>,
        <dfn data-cite="SPARQL11-QUERY#defn_PropertyPathPattern">property path pattern</dfn>,
        <dfn data-cite="SPARQL11-QUERY#defn_PropertyPathExpr">property path expression</dfn>,
        <dfn data-cite="SPARQL11-QUERY#defn_QueryVariable" data-lt="variable">query variable</dfn>,
        <dfn data-cite="SPARQL11-QUERY#defn_SolutionMapping">solution mapping</dfn>,
        ...

      </p>
    </section>

    <section>
      <h2>Translation to the algebra</h2>

      <p>Based on the SPARQL grammar the SPARQL specification <q>defines the process of converting graph patterns and solution modifiers in a SPARQL query string into a SPARQL algebra expression</q> [<a data-cite="SPARQL11-QUERY#sparqlQuery">SPARQL11-QUERY, Section 18.2</a>].  This process must be adjusted to consider the extended grammar introduced <a href="#sparql-star-grammar">above</a>. In the following, any step of the conversion process that requires adjustment is discussed.</p>

      <section>
        <h2>Variable Scope</h2>

        <p>As a basis of the translation, the SPARQL specification introduces a notion of <a data-cite="SPARQL11-QUERY#variableScope">in-scope variables</a>. To cover the new syntax elements introduced in <a href="#sparql-star-grammar"></a> this notion MUST be extended as follows.</p>

        <ul>
          <li>A <a>variable</a> is in-scope of a <a>BGP*</a> |B| if the <a>variable</a> occurs in |B|, which includes an occurrence in any <a>embedded triple pattern</a> in |B| (independent of the level of nesting).</li>
          <li>A <a>variable</a> is in-scope of a <a>property path pattern</a> if the variable occurs in that pattern, which includes an occurrence in any embedded triple pattern in the pattern (independent of the level of nesting).</li>
          <li>A <a>variable</a> is in-scope of a BIND clause of the form `BIND ( T AS v )` (where |T| is an <a>embedded triple pattern</a>) if the variable is variable |v| or the variable occurs in the <a>embedded triple pattern</a> |T|. As for standard BIND clauses with expressions, variable |v| must <q>not [be] in-scope from the preceeding elements in the group graph pattern in which [the BIND clause] is used</q> [<a data-cite="SPARQL11-QUERY#variableScope">SPARQL11-QUERY, Section 18.2.1]</a>].</li>
        </ul>
      </section>

      <section>
        <h2>Expand Syntax Forms</h2>

        <p>The translation process starts with expanding <q>abbreviations for IRIs and triple patterns</q> [<a data-cite="SPARQL11-QUERY#sparqlExpandForms">SPARQL11-QUERY, Section 18.2.2.1</a>]. This step MUST be extended in two ways:</p>

        <ol>
          <li><div>
            <p>Abbreviations for <a>triple patterns</a> with <a>embedded triple patterns</a> MUST be expanded as if each <a>embedded triple pattern</a> was a <a>variable</a> (or an <a>RDF term</a>).

            <div class="example">
              For instance, the following syntax expression:
              <pre data-transform="updateExample" 
                data-content-type="application/sparql-query"
                class="nohighlight"
              >
                <!--
                <<?c a rdfs:Class>> dct:source ?src ;
                    prov:wasDerivedFrom <<?c a owl:Class>> .
                -->
              </pre>
              must be expanded to
              <pre data-transform="updateExample" 
                data-content-type="application/sparql-query"
                class="nohighlight"
              >
                <!--
                <<?c a rdfs:Class>> dct:source ?src .
                <<?c a rdfs:Class>> prov:wasDerivedFrom <<?c a owl:Class>> .
                -->
              </pre>
            </div>  
          </div></li>
          <li><div>
            <p>Abbreviations for IRIs in all <a>embedded triple patterns</a> MUST be expanded.</p>

            <div class="example">
              For instance, the embedded triple pattern
              <pre data-transform="updateExample" 
                data-content-type="application/sparql-query"
                class="nohighlight"
              >
                <!--
                <<?c a rdfs:Class>>
                -->
              </pre>
              must be expanded to
              <pre data-transform="updateExample" 
                data-content-type="application/sparql-query"
                class="nohighlight"
              >
                <!--
                <<?c <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.w3.org/2000/01/rdf-schema#Class>>>
                -->
              </pre>
            </div>
          </div></li>
        </ol>
      </section>

      <section>
        <h2>Translate Property Path Patterns</h2>

        <p>The <a data-cite="SPARQL11-QUERY#sparqlTranslatePathPatterns">translation of property path patterns</a> has to be adjusted because the extended grammar allows for property path patterns whose subject or object is an <a>embedded triple pattern</a> (cf. <a href="#sparql-star-grammar"></a>).</p>

        <p>The translation as specified in the W3C specification distinguishes four cases. The first three of these cases do not require adjustment because they are taken care of either by recursion or by the adjusted translation of basic graph patterns (as defined in <a href="#translate-bgp"></a> below). However, the fourth case MUST be adjusted as follows.</p>

        <p>Let |X| |P| |Y| be a string that corresponds to the fourth case in [<a data-cite="SPARQL11-QUERY#sparqlTranslatePathPatterns">SPARQL11-QUERY, Section 18.2.2.4</a>]. Given the grammar introduced in <a href="#sparql-star-grammar"></a>, |X| and |Y| may be an <a>RDF term</a>, a <a>variable</a>, or an <a>embedded triple pattern</a>, respectively (and |P| is a <a>property path expression</a>). The string |X| |P| |Y| is translated to the algebra expression `Path`(<var>X’</var>,|P|,<var>Y’</var>) where <var>X’</var> and <var>Y’</var> are the result of calling a function named `Lift` for |X| and |Y|, respectively. For some input string |Z| (such as |X| or |Y|) that can be an <a>RDF term</a>, a <a>variable</a>, or an <a>embedded triple pattern</a>, the function `Lift` is defined as follows:</p>

        <ol id="lift">
          <li>If |Z| is an <a>embedded triple pattern</a> &lt;&lt;|S|,|P|,|O|&gt;&gt; then return the <a>triple* pattern</a> (`Lift`(|S|, |P|, `Lift`(|O|));</li>
          <li>Otherwise, return |Z|.</li>
        </ol>
      </section>

      <section id="translate-bgp">
        <h2>Translate Basic Graph Patterns</h2>

        <p>After translating <a>property path patterns</a>, the translation process collects <q>any adjacent triple patterns [...] to form a basic graph pattern</q> [<a data-cite="SPARQL11-QUERY#sparqlTranslateBasicGraphPatterns">SPARQL11-QUERY, Section 18.2.2.5</a>]. This step has to be adjusted because <a>triple patterns</a> in the extended syntax may have an <a>embedded triple pattern</a> in their subject position or in their object position (or in both). To ensure that every result of this step is a <a>BGP*</a>, before adding a <a>triple pattern</a> to its corresponding collection, its subject and object MUST be replaced by the result of calling <a href="#lift">function `Lift`</a> for the subject and the object, respectively.</p>
      </section>

      <section id="translate-bind">
        <h2>Translate BIND Clauses with an Embedded Triple Pattern</h2>

        <p>The extended grammar in <a href="#sparql-star-grammar"></a> allows for BIND clauses with an <a>embedded triple pattern</a>. The translation of such a BIND clause to a SPARQL algebra expression requires a new algebra symbol:</p>

        <ul>
          <li>TR( <a>triple* pattern</a>, <a>variable</a> )</li>
        </ul>

        <p>Note that this symbol corresponds to <a>SPARQL* expressions</a> of the form (`tp` AS `?v`).</p>

        <p>Then, any string of the form `BIND( T AS v )` with |T| being an <a>embedded triple pattern</a> (i.e., not a standard BIND expression) is translated to the algebra expression `TR`(<var>T’</var>, |v|) where <var>T’</var> is the result of the <a href="#lift">function `Lift`</a> for |T|.</p>

        <p>Notice, the translation of BIND clauses with an <a>embedded triple pattern</a> as defined in this section is used during <a data-cite="SPARQL11-QUERY#sparqlTranslateGraphPatterns">the translation of group graph patterns</a>. The case of BIND clauses with an <a>embedded triple pattern</a> is covered in this translation of group graph patterns by the last, “catch all other” `IF` statement (i.e., the `IF` statement with the condition `E is any other form`) and not by the `IF` statement for BIND clauses with an expression.</p>
      </section>
    </section>

    <section>
      <h2>Evaluation Semantics</h2>

      <p>The SPARQL specification defines a function “eval(D(G), algebra expression) as the evaluation of an algebra expression with respect to a dataset D having active graph G”[<a href="SPARQL11-QUERY#sparqlAlgebraEval">SPARQL11-QUERY, Section 18.6</a>]. Recall that the active graph |G| in the context of SPARQL* is an <a>RDF* graph</a>, and so is any other graph in dataset |D|. The definition of function eval is recursive; the two base cases of this definition for SPARQL* are given as follows:</p>

      <ul>
        <li>For any <a>BGP*</a> |B|, eval(D(|G|), |B|) = ⟦|B|⟧<sub>|G|</sub>(where ⟦|B|⟧<sub>|G|</sub> is the <a>evaluation</a> of |B| over <a>RDF* graph</a> |G|.</li>

        <li>For any algebra expression |E| of the form TR(|tp|, |?v|) where |tp| is a <a>triple* pattern</a> and |?v| is a <a>variable</a> (as introduced <a href="#translate-bind"></a>>), eval(D(|G|), |E|) = ⟦(|tp| AS |?v|)⟧<sub>|G|</sub> (where ⟦(|tp| AS |?v|)⟧<sub>|G|</sub> is the <a>evaluation</a> of SPARQL* expression (|tp| AS |?v|) over <a>RDF* graph</a> |G|.</li>
      </ul>

      <p class="issue">⟦|B|⟧<sub>|G|</sub> is not defined anywhere here, and neither is ⟦(|tp| AS |?v|)⟧<sub>|G|</sub>.  -Olaf</p>

      <p>For any other algebra expression, the SPARQL specification defines algebra operators [[SPARQL11-QUERY]]. These definitions can be extended naturally to operate over multisets of <a>solution* mappings</a> (instead of ordinary <a>solution mappings</a>). Given this extension, the recursive steps of the definition of function eval for SPARQL* are the same as in the SPARQL specification.</p>
    </section>

  </section>

  <section>
    <h2>RDF* semantics</h2>

    <p>
      Here we extend RDF <abbr title="model theoretic">MT</abbr> semantics [[RDF11-MT]] to RDF*.
      Referring to <a>blank node</a>.
      TODO
    </p>

  </section>
</body>
</html>